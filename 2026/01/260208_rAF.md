---
type: "content"
domain: "frontend"
category: "animation"
topic: "rAF"
updatedAt: "2026-02-08"

satisfaction:
  score: 100
  reason: "rAF의 중요성을 인지하게 된 점"

keywords:
  - "rAF"
  - "animation"
  - "accessibility"

relatedCategories:
  - "html"
  - "accessibility"
---

# requestAnimationFrame

`requestAnimationFrame`은 브라우저에게 애니메이션을 요청하는 함수이다.  
`setTimeout`이나 `setInterval`과 달리, `requestAnimationFrame`은 브라우저의 렌더링 주기에 맞춰 애니메이션을 요청한다.  

보통 60fps로 동작하는 브라우저에서 1초에 60번의 애니메이션을 요청한다.  
밀리초 단위로 계산 해보면, 16.666ms 마다 애니메이션을 요청하는 것이다.  
이 한 요청 사이클을 제어할 수 있는 것이 바로 `requestAnimationFrame`이다.  

```ts
function animate() {
  // 애니메이션 로직
  requestAnimationFrame(animate);
}

requestAnimationFrame(animate);
```

최근에 GoalSeek이라는 목표 값 찾기 기능을 구현하면서, `requestAnimationFrame`을 활용해 보았다.  
목표 값을 찾는 알고리즘이 동작할 때, 연산 횟수가 기하급수적으로 늘어난다면 프레임 드랍이 발생할 수 있다.  
이는 브라우저 메인 스레드를 연산을 수행하는 함수가 점유하여 React 엔진의 렌더링을 방해하기 때문이다.  

[![](https://mermaid.ink/img/pako:eNp1U11PE0EU_Ss380JJCtqln_vAg0hMHzRGqA-mL0M7LI3bnTrdRZH0obIkUCAGU6AkxdRYizGYbKAxfegv6sz-B2c_StXW2WR37s459545d2YXFWiRIBVVyRuLGAXyuIQ1hst5A-TAlkkNq7xBWBBXMDNLhVIFGybkAFchV525lPXXshCR2XSqPVjHGzqZnwauGlrJIB54BeuFMJyGrZnY9FHB5Ck2sObVDZC5heXlXFYFcdR1zw-B39puYwhuvc97P0NEVkJ8rgr8x3d-dAOi1XWbB8CdjyD6B6OBA7x3IxpdtzEA3jnmJ01-XQ_YwVuntAKr24TtwBOKdVgj5DVkTRI65Q2_QijGbdnisyxzZourvrvfhjlx4YgPDoju6RyIvbq71wZxsc9PHA_QGEzS-Gr9HOeHkRf07Ty4Zy0J4lfDABqollqbQ24fgHvaFkftCX9aUOCrdCiUcHY8uut4--21pNCB-NWGyDpmGjHhJdatcaf8E1AwS9ue6X_2xhvPqPxJpR8wzi7NYFiiid9MS5dzakwIAWxh0olQzejWGd0N5Z5a7mVrAi-S_5ae7fi9wZc2_3p877HnVVBi5Hz6t7V_2S2ubek4_9aJPGdUY6RahUeYzc_oEjGK94fPZ0tyxxa3fXCbNv_SFvZAtidU4tnNe0MURRorFZFqMotEUZmwMvZCtOslyiNzi5RJHqlyWiSb2NLNPMobNUmTV-AVpeUxk1FL2xoHVqUoHQjvLFI3sV71IFIgYSvUMkykxhIZPwdSd9E7pGZSi_FURlGUeCKWTMSTUbSDVCW5qGQSyXQ8lVDkE0unalH03i_6cDGtJJWlZDojP0pqKRWr_QYjoqqd?type=png)](https://mermaid.live/edit#pako:eNp1U11PE0EU_Ss380JJCtqln_vAg0hMHzRGqA-mL0M7LI3bnTrdRZH0obIkUCAGU6AkxdRYizGYbKAxfegv6sz-B2c_StXW2WR37s459545d2YXFWiRIBVVyRuLGAXyuIQ1hst5A-TAlkkNq7xBWBBXMDNLhVIFGybkAFchV525lPXXshCR2XSqPVjHGzqZnwauGlrJIB54BeuFMJyGrZnY9FHB5Ck2sObVDZC5heXlXFYFcdR1zw-B39puYwhuvc97P0NEVkJ8rgr8x3d-dAOi1XWbB8CdjyD6B6OBA7x3IxpdtzEA3jnmJ01-XQ_YwVuntAKr24TtwBOKdVgj5DVkTRI65Q2_QijGbdnisyxzZourvrvfhjlx4YgPDoju6RyIvbq71wZxsc9PHA_QGEzS-Gr9HOeHkRf07Ty4Zy0J4lfDABqollqbQ24fgHvaFkftCX9aUOCrdCiUcHY8uut4--21pNCB-NWGyDpmGjHhJdatcaf8E1AwS9ue6X_2xhvPqPxJpR8wzi7NYFiiid9MS5dzakwIAWxh0olQzejWGd0N5Z5a7mVrAi-S_5ae7fi9wZc2_3p877HnVVBi5Hz6t7V_2S2ubek4_9aJPGdUY6RahUeYzc_oEjGK94fPZ0tyxxa3fXCbNv_SFvZAtidU4tnNe0MURRorFZFqMotEUZmwMvZCtOslyiNzi5RJHqlyWiSb2NLNPMobNUmTV-AVpeUxk1FL2xoHVqUoHQjvLFI3sV71IFIgYSvUMkykxhIZPwdSd9E7pGZSi_FURlGUeCKWTMSTUbSDVCW5qGQSyXQ8lVDkE0unalH03i_6cDGtJJWlZDojP0pqKRWr_QYjoqqd)

컨셉은 위와 같은 형태의 연산이다.  
이러한 과정에서 연산이 진행되는 동안 연산 알고리즘이 멈추지 않고 계속 실행된다면, React 엔진은 렌더링을 수행할 수 없어 화면이 멈추는 현상이 발생한다.  
이러한 문제를 해결하기 위해,  
개발자가 브라우저 렌더링 주기를 제어할 수 있는 브라우저 API인 `requestAnimationFrame`을 사용해야 한다.  
물론, Web Worker를 활용하여 연산 알고리즘을 별도의 스레드에서 실행하는 방법도 있다.  
이걸 시도해보고 싶었지만, SpreadJS라는 시트 라이브러리와 지속적인 연동을 수행해야 했기에, 메인 스레드에서 연산을 수행할 수 밖에 없었다. (핑계일지도..)  

## rAF의 동작 원리

브라우저에 은행 창구 직원이 한 명 있다고 가정해보면 이해가 쉬운거 같다.  
첫번 째, 고객이 `목표 값 찾기` 100번 실행을 요청했다.  
두번 째, 고객은 `대화상자 렌더링`을 요청했다.  

창구 직원(브라우저)은 첫번 째 고객의 요청을 처리하느라 바쁘다.  
이때 두번 째 고객이 `대화상자 렌더링`을 요청하면, 창구 직원은 두번 째 고객의 요청을 처리할 수 없다.  
근데 만약 requestAnimationFrame이 포함된 요청이라면, 창구 직원은 다음 16.66ms 후에 해당일을 처리할 수 있게 된다.  

요청을 바꿔보면,
첫번 째, 고객이 `목표 값 찾기` rAF(1) * 100번 실행을 요청했다.  
rAF요청은 16.66ms 이후 처리를 요하는 요청이므로, 현 시점에는 예약만 해두고 다음 고객의 요청을 접수한다.  
두번 째, 고객이 `대화상자 렌더링`을 요청했다.  
이때 창구 직원은 대화상자 렌더링을 즉각적으로 실행한다.  

이로써 사용자가 실행 버튼을 클릭하는 순간 대화상자가 렌더링되고, 그 이후에 목표 값 찾기 연산이 100번 실행되는 것이다.  
이러한 방식으로 rAF를 활용하면, 브라우저 렌더링 주기를 제어하여 애니메이션을 부드럽게 구현할 수 있다.  
다만, 그럼 이후 100번의 연산 동안 메인 스레드 점유에 의해 UI는 멈춰 있어야 할까?  
여러 기법들이 있겠지만, `waitForRender` 함수를 하나 구현해서 연산 로직 시작점에 끼워 넣으면 매 연산 시작점에 렌더링(상태 변경 -> UI 업데이트)을 유도할 수 있다.  

```ts
function waitForRender() {
  return new Promise<void>((resolve) => {
    requestAnimationFrame(() => {
      resolve();
    });
  });
}
```

근데 만약, 한 번의 연산이 너무 오랜시간이 걸린다면 브라우저의 프레임 드랍은 발생할 수 밖에 없다.  
최초 상태 변경은 렌더링 했지만, 연산이 너무 오래 걸렸다면 UI 업데이트가 이루어지지 않을 것이다.  
그럼 이때 또 제어할 수 있는 트릭은 없을까?  
이때 쓰이는 것이 setTimeout 트릭이다.  

## setTimeout(fn, 0)을 이용한 UI 업데이트 시간을 버는 트릭

자바스크립트 엔진은 setTimeout을 만나면, 이건 내 할일이 아님, 브라우저(Web API)에게 니가 관리해 라고 일을 던져 버리게 된다.  
지연 시간 0ms로 설정해도, 최소 4ms의 시간이 확보되며, 이 시간동안 브라우저는 해당 콜백을 Macro Task queue에 넣는다.  
이 시점에 현재 실행 중이던 연산 함수가 종료되어 Call Stack이 비워진다.  
이벤트 루프는 다음 Task를 실행하기 전에 "렌더링 할 거 있어?"를 체크한다.  
만약 렌더링이 필요하다면, 브라우저는 화면 갱신을 우선 처리한다.  
이 원리를 이용해서 틈새 공략을 하는 것 이다.

`목표 값 찾기`라는 연산은 기본 원리 자체가 interation이다.  
하나의 연산은 크지 않지만, 수백만번, 수천만번 연산을 수행하며 수렴하는 결과 값을 찾는다.  
상대적으로 비용이 적은 하나의 연산 단위를 10개 혹은 20개 정도로 묶어 20번의 연산 마다 setTimeout(fn, 0)을 수행 시켜버린다.  
이렇게 하면 최소한 긴 연산을 수행하는 중간에 무제한 프레인 드랍은 방지할 수 있게 된다.  

지금은 이 정도로 최소 수준의 최적화를 수행하고 있다.  
나중에 프레임 드랍이나 사용자 피드백이 늘게 된다면, 아래 방식을 추가로 적용해봐야 할듯 하다.  

지금 이 내용을 정리하다, scheduler.yield()라는 연산을 보게 되어 추가로 정리 해본다.  

## scheduler.yield()

> scheduler.yield()는 앞서 설명한 setTimeout(0) 트릭의 현대적이고 우아한 해결책입니다.  
> 구글 Chrome 팀이 주도하여 만든 Prioritized Task Scheduling API의 일부로,  
> "브라우저에게 잠깐 양보하고, 급한 일 끝나면 바로 나한테 돌아와"라고 명시적으로 협상하는 도구. 

오.. 시간만 주어진다면, 적용해보고 싶다.  
아마 곧 쓸일이 오지 않을까 싶긴한데,  
"브라우저에게 잠깐 양보하고, 급한 일 끝나면 바로 나한테 돌아와"라는 메세지가 임팩트를 가진다.  

"내가 지금 큰 일을 하고 있는데, 혹시 대기실에 응급 환자 있어? 있으면 걔 먼저 처리해줘. 다 처리하면 내가 줄 맨 앞에서 기다릴테니 바로 불러줘."  
최적화에 최적화까지 더 해진 느낌이다.  

하위 호환성을 위해 setTimeout(fn, 0) 트릭까지 포함된 함수는 아래와 같다.  

```ts
// 작동하는 재료: 환경에 따른 최적화된 양보 함수
const yieldIfPossible = async () => {
  if ('scheduler' in window && 'yield' in (window as any).scheduler) {
    return await (window as any).scheduler.yield();
  }
  // 폴백: 구형 브라우저를 위한 매크로태스크 트릭
  return new Promise(resolve => setTimeout(resolve, 0));
};

async function performMassiveGoalSeek(data: any[]) {
  let lastYieldTime = performance.now();

  for (let i = 0; i < data.length; i++) {
    process(data[i]);

    // 전략: 무조건 양보하지 않고, 16ms(1프레임)가 지났을 때만 양보
    // 이를 통해 연산 속도와 UI 응답성 사이의 균형을 잡음 (Time-slicing)
    if (performance.now() - lastYieldTime > 16) {
      await yieldIfPossible();
      lastYieldTime = performance.now();
    }
  }
}
```

rAF와 yield가 적용된 시퀀스 다이어그램을 그려본다면?

[![](https://mermaid.ink/img/pako:eNp9VNtOE0EYfpU_c7VNoNJStnQvTIyn9EJj1HphejN2x7JxD3UPRCQkVJYEoUSIVRbdElQUSWqyIppewAt1Zt_Bmd1WWiVuk-afme_7_uPMIqpZKkEKcshTj5g1ck3DdRsbVRP4hz3XMj3jEbHTdQPbrlbTGth0oQLYgYpz4VE5OSvD_TmbYBWkW1gzM__i7mgNIpB3iakSWzPryY6umeRf7HWzzvcF-qaF9XuEPBlsVc0UXJm8fLlSVoBtHMRvXwI99uP1U4ibJ_TLtxSR_t-2XALWPLFBoO0rN-jnU2AvuuzdUfwmYDtdoPstutmmh01gwRp7czbQL3MHIr6EBOwspNF3oK-_0w8dkGhrOd5ts5Um29uCeDtkG2HmYq-pBN04YJ0WPJi8t2DWQOJeICdnZcOB-L0_YArkIKkRj8P8olfAPdKjE7jDq-v-CVIwuP5IPJfi1RbrnNBem5PDftTkJ8B2ffqpNSzeeXhpUXkZdyL2IgL66Wvc9gWP7W2nWN2yGnALO442T6DsEhu7mmU66aH4Ugkex1CrH4X0hz-UZGuBSEBq2FaNOE7mnHhuYd3l9TAcKce90_01tudnoH981v9xKmI5B14c_H3NIJOOzmeHzxSNQrbSGaf8CVEU16nNEdXTiZ1d0IiuShmgwRZdb4NDXKFkea40lYE46LFff7nGNVebx9x9pTx-MDItvBX9Hk_7YJt1euJWsJ1VuhnxjsTrvUuiMccH3AJ2HNAv3XGZZATSjrJDX5QtDvx494gnFbCgCdINflcJsHCfHS5nxrkq-V90I-0Z9mWvyxsF0l3ieAYZEeO3M10kRmqOFZD9DNnHVd6fKOnPvk83un_N49BHMnXA5zJeCQf3BE2guq2pSHFtj0wgg9gGFku0KDSqyJ0jBqkihZsqeYw93a2iqrnEafxheGhZxpBpW159brjwGirPfPCaIeUx1h0BSV6aq5ZnukjJydOJBlIW0TOklIrZQrGUz-cLMzl5piBPoAWk5OVsvjQjzxaKM3n-y80WlybQ88TpVHY2L-en5dLUtCwXC4XS7NJvJe8THQ?type=png)](https://mermaid.live/edit#pako:eNp9VNtOE0EYfpU_c7VNoNJStnQvTIyn9EJj1HphejN2x7JxD3UPRCQkVJYEoUSIVRbdElQUSWqyIppewAt1Zt_Bmd1WWiVuk-afme_7_uPMIqpZKkEKcshTj5g1ck3DdRsbVRP4hz3XMj3jEbHTdQPbrlbTGth0oQLYgYpz4VE5OSvD_TmbYBWkW1gzM__i7mgNIpB3iakSWzPryY6umeRf7HWzzvcF-qaF9XuEPBlsVc0UXJm8fLlSVoBtHMRvXwI99uP1U4ibJ_TLtxSR_t-2XALWPLFBoO0rN-jnU2AvuuzdUfwmYDtdoPstutmmh01gwRp7czbQL3MHIr6EBOwspNF3oK-_0w8dkGhrOd5ts5Um29uCeDtkG2HmYq-pBN04YJ0WPJi8t2DWQOJeICdnZcOB-L0_YArkIKkRj8P8olfAPdKjE7jDq-v-CVIwuP5IPJfi1RbrnNBem5PDftTkJ8B2ffqpNSzeeXhpUXkZdyL2IgL66Wvc9gWP7W2nWN2yGnALO442T6DsEhu7mmU66aH4Ugkex1CrH4X0hz-UZGuBSEBq2FaNOE7mnHhuYd3l9TAcKce90_01tudnoH981v9xKmI5B14c_H3NIJOOzmeHzxSNQrbSGaf8CVEU16nNEdXTiZ1d0IiuShmgwRZdb4NDXKFkea40lYE46LFff7nGNVebx9x9pTx-MDItvBX9Hk_7YJt1euJWsJ1VuhnxjsTrvUuiMccH3AJ2HNAv3XGZZATSjrJDX5QtDvx494gnFbCgCdINflcJsHCfHS5nxrkq-V90I-0Z9mWvyxsF0l3ieAYZEeO3M10kRmqOFZD9DNnHVd6fKOnPvk83un_N49BHMnXA5zJeCQf3BE2guq2pSHFtj0wgg9gGFku0KDSqyJ0jBqkihZsqeYw93a2iqrnEafxheGhZxpBpW159brjwGirPfPCaIeUx1h0BSV6aq5ZnukjJydOJBlIW0TOklIrZQrGUz-cLMzl5piBPoAWk5OVsvjQjzxaKM3n-y80WlybQ88TpVHY2L-en5dLUtCwXC4XS7NJvJe8THQ)