---
type: "content"
domain: "frontend"
category: "performance"
topic: "concurrent-feature"
updatedAt: "2025-11-30"

satisfaction:
  score: 75
  reason: "React 동시성 연구 배경과 블로킹 문제, 디바운싱 한계를 명확히 설명"

keywords:
  - "React18"
  - "concurrency"
  - "blocking"
  - "debouncing"
  - "throttling"
  - "useTransition"
  - "virtual-DOM"

relatedCategories:
  - "javascript"
  - "performance"
---

# React 18 동시성 - 개요

React가 동시성을 연구한 이유와 브라우저 렌더링 블로킹 문제의 해결 방법을 정리한다.  
디바운싱/스로틀링의 한계를 넘어, 즉각적인 반응과 지연 상태 변화를 구분하는 동시성 렌더링의 핵심을 이해한다.

> 학습 URL: https://tech.remember.co.kr/%EC%BD%94%EB%93%9C-%ED%95%9C-%EC%A4%84%EB%A1%9C-%EA%B2%BD%ED%97%98%ED%95%98%EB%8A%94-react-%EB%8F%99%EC%8B%9C%EC%84%B1%EC%9D%98-%EB%A7%88%EB%B2%95-5ff18aee148d

## 학습 진행도

- ✅ [React는 동시성을 왜 연구했을까?](#react는-동시성을-왜-연구-했을까)
- ✅ [블로킹](#블로킹)
- ✅ [디바운싱 or 스로틀링](#디바운싱-or-스로틀링)
- ✅ [즉각적인 반응과 지연을 예상하는 상태변화](#즉각적인-반응과-지연을-예상하는-상태변화)
- 🚧 [레인(Lane)모델과 동시성 렌더링]()
- 🚧 [레인의 구현방식]()
- 🚧 [비트연산]()
- 🚧 [우선순위]()
- 🚧 [Expiration Time 모델의 한계와 레인모델의 장점]()
- 🚧 [레인모델이 동시성을 지원하는 방식]()
- 🚧 [만료시간 관리]()
- 🚧 [얽힘(Entanglement) 메커니즘]()
- 🚧 [useDeferredValue와 useTransition]()

## React는 동시성을 왜 연구 했을까?

- 브라우저의 렌더링 블로킹 문제를 해결하기 위해,
- 브라우저 메인 스레드의 역할은 js 실행, DOM 조작, 스타일 계산, 레이아웃 페인팅.. 모두 싱글스레드!
- 단일 스레드 이므로, 하나의 작업이 시작되면 이후 작업은 모두 블로킹이 됨.
- 일반적으로는 React의 virtual DOM이나 diff 알고리즘이 굉장히 빠르므로 별문제 안됨.
- 하지만 수십만개의 복잡한 데이터 목록을 filter하거나 sort 하면 화면이 버벅임. (예시, https://gtw6kl.csb.app/)

## 블로킹

- js의 연산이 길어지면서 프레임이 드롭되고, 사용자 입력은 뒤로 밀림.
- 부드럽게 동작해야 할 애니메이션이 끊기고, 버튼 클릭이나 입력이 지연되는 현상 발생.

## 디바운싱 or 스로틀링

- 전통적인 문제 해결 방식은 디바운싱과 스로틀링 이었음.
- 하지만 이런 방식은 사용자의 입력 속도를 예측해야하는 한계가 있었음. (이걸 어떻게 다..)

> 사용자는 물리적인 행위에 대해서 즉각적인 반응을 기대한다. 그렇지 않다면 사용자는 뭔가 잘못되고 있다고 느낄 수 있다. <br />
> 반면 A0 -> A1의 전환은 느릴 수 있다고 무의식적으로 인지하고 있으며, 모든 전환에 대한 즉각적인 반응을 기대하지 않는다.

## 즉각적인 반응과 지연을 예상하는 상태변화

- 버튼 클릭, 키보드 입력, 화면 터치와 같은 물리적 상호작용에서는 실제 세계처럼 즉각적인 반응을 기대함.
- 반면, 검색 결과 로딩, 화면 전화 등의 상태 변화에 대해서는 사용자가 무의식적으로 지연을 예상함.
- 버그 혹은 오류로 느끼는가와 아닌가에 대한 차이

## 동시성 렌더링의 핵심은?

- 메인 스레드에게 일정 시간을 양보(yield) 한다는 점.
- 렌더링을 이어가다 잠시 멈추고, 메인 스레드가 다른 작업을 처리할 수 있는 시간을 줌.
- 이때 브라우저는 이벤트 처리가 가능하고 덕분에 사용자 경험(UX)이 좋아지게 됨.

## 렌더링 중에 새로운 사용자 입력이 발생한다면?

- 동작하는 방식을 우선순위로 분류 해놓음.
- 우선 순위 낮은 동작은 잠시 멈춤.
- 우선 순위 높은 동작을 메인 스레드에 할당 해버림.

## 개발자로써 해야 하는 건?

- 물리적 반응과 상태 변화를 정의한다.
- useTransition을 사용해 적절히 이용한다.

# Next?

- useTransition의 동작원리를 살펴보고 어떻게 적용하는게 좋을지 고민해본다. (Detail 파악 -> 예시 코드 작성 및 테스트)
