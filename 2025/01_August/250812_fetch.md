---
type: "skill"
domain: "frontend"
category: "javascript"
topic: "async"
updatedAt: "2025-11-30"

keywords:
  - "fetch"
  - "await"
  - "Response"
  - "streaming"
  - "HTTP"

relatedCategories:
  - "typescript"
---

# fetch API의 두 번 await 패턴

fetch API를 사용할 때 왜 두 번 await를 하는지, 그 이유와 장점을 정리한다.  
HTTP 응답의 헤더→본문 순서 도착 특성을 이해하면 성능 최적화와 에러 핸들링을 효율적으로 할 수 있다.

## 쓰는 이유

1. **네트워크 구조 특성**
   - HTTP 응답은 **헤더 → 본문** 순서로 도착
   - `fetch()`는 헤더만 받아도 `Response` 객체 반환 가능
2. **단계별 비동기 처리**
   - 첫 번째 await: 요청 전송 + 헤더 수신 대기
   - 두 번째 await: 본문 스트림 읽기 + 파싱 대기
3. **에러 핸들링 효율**
   - 헤더만 보고 상태 코드(`status`)로 실패 여부 판단 가능 → 불필요한 본문 읽기 방지

---

## 장점

- **성능 최적화**
  - 불필요한 데이터 다운로드 방지
- **대용량 데이터 대응**
  - 스트리밍 방식으로 처리 가능
- **코드 가독성**
  - 요청과 응답 처리 로직을 단계별로 명확하게 구분
- **유연한 처리**
  - 헤더 기반 조건 분기(예: 인증 실패 시 본문 읽기 생략)

---

## 예시 코드

```javascript
// 첫 번째 await: 서버 응답 헤더까지 받기
const res = await fetch("https://api.example.com/data");

// 상태 코드 확인 (헤더만으로 판단 가능)
if (!res.ok) {
  console.error("HTTP Error:", res.status);
  return;
}

// 두 번째 await: 본문 읽고 JSON 변환
const data = await res.json();
console.log("받은 데이터:", data);
```
