# JavaScript `fetch` 두 번 `await` 하는 이유와 장점

## 쓰는 이유

1. **네트워크 구조 특성**
   - HTTP 응답은 **헤더 → 본문** 순서로 도착
   - `fetch()`는 헤더만 받아도 `Response` 객체 반환 가능
2. **단계별 비동기 처리**
   - 첫 번째 await: 요청 전송 + 헤더 수신 대기
   - 두 번째 await: 본문 스트림 읽기 + 파싱 대기
3. **에러 핸들링 효율**
   - 헤더만 보고 상태 코드(`status`)로 실패 여부 판단 가능 → 불필요한 본문 읽기 방지

---

## 장점

- **성능 최적화**
  - 불필요한 데이터 다운로드 방지
- **대용량 데이터 대응**
  - 스트리밍 방식으로 처리 가능
- **코드 가독성**
  - 요청과 응답 처리 로직을 단계별로 명확하게 구분
- **유연한 처리**
  - 헤더 기반 조건 분기(예: 인증 실패 시 본문 읽기 생략)

---

## 예시 코드

```javascript
// 첫 번째 await: 서버 응답 헤더까지 받기
const res = await fetch("https://api.example.com/data");

// 상태 코드 확인 (헤더만으로 판단 가능)
if (!res.ok) {
  console.error("HTTP Error:", res.status);
  return;
}

// 두 번째 await: 본문 읽고 JSON 변환
const data = await res.json();
console.log("받은 데이터:", data);
```
