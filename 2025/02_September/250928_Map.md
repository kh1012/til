# MAP

생각없이 캐스팅하듯 Array.from을 쓰다가 불현듯 이게 왜 가능한가에 대한 근본적 의문이 들기 시작함.  
예를 들어 map.keys()가 왜 전개연산과 Array.from의 인자가 될 수 있는가?  
Iterator를 보는 순간 반가움에 그만, 이걸 공부해봐야겠다고 마음먹음.  

## Iterable
[타입 스크립트 공식문서 (이터러블)](https://www.typescriptlang.org/ko/docs/handbook/iterators-and-generators.html)  
공식문서에 가보면, 사전적 정의로 아래와 같이 작성되어 있다. 
> Symbol.iterator 프로퍼티에 대한 구현을 가진 객체는 이터러블로 간주합니다.  

Primitive 자료형 중에 Symbol이란 놈이 어떤 역할인지 궁금하긴 했는데,  
세상에 이걸 객체 생성이 가능한 클래스 내에 구현하면, Iterable 즉 순회 가능한 상태가 된다는 것.  

## for ... in

for ... in은 모든 객체에 대해서 프로퍼티의 키를 순회할 수 있음.  
Set, Map, Array, ...  

## for ... of

for ... of는 말그대로 Iterable 객체에 대해서만 순회가 가능함.  
결국 Symbol.iterator가 해당 객체에 정의되어 있다는 것.  

## Iterator 객체

Iterator 객체는 Iterator 프로토콜을 따르는 형태의 객체를 말한다.
```ts
class ItrClass {
    start: number;
    stop: number;
    value: number;
    
    constructor(start, stop) {
        this.start = start;
        this.stop = stop;
        this.value = start;
    }
    
    next() {
        if (this.value <= this.stop) {
            return { done: false, value: this.value++ }
        } else {
            return { done: true, value: undefined }
        }
    }
}
```
이로써 Iterator 프로토콜은 따르게 되지만, 이전에 설명했던 for ... of를 사용하려면,  
Symbol.iterator를 속성으로 가져야 한다. 그리고 보통 자기자신을 되돌려준다.  

```ts
class ItrClass {
    start: number;
    stop: number;
    value: number;
    
    constructor(start, stop) {
        this.start = start;
        this.stop = stop;
        this.value = this.start;
    }
    
    next(): IteratorResult<number> {
        if (this.start <= this.stop) {
            return { done: false, value: this.value++ }
        } else {
            return { done: true, value: undefined }
        }
    }
    
    [Symbol.iterator](): Iterator<number> {
        return this;
    }
}
```
ß
