# 서론

웹 개발을 약 3년간 진행했다.  
그리고 extends를 통해 상속이 가능하다는 건 알고 있었다.  
하지만 최근에 들어서야, 클래스 개념, 즉 OOP를 JS에서도 많이 적용하려고 한다는 걸 인지하게 되었다.  
무조건 적으로 일차함수, 즉 INPUT / OUPUT이 분명한 형태의 함수형 프로그래밍이 답(?)이라고 생각했던 것 같다.  
최근에 타입스크립트 공부를 진행하면서, 역시 근본은 OOP인가를 다시금 깨닫고 있다.  
파일 한 2개의 짧은 코드에서는 사실 상 객체를 정의한다는 게 오히려 피로감이 큰 행위이다.  
코드 베이스가 커지고 라인이 늘어나게 되면 공통적인 부분을 추상화해야하고, 재사용성을 점차 고려해야 한다.  
이때, 혜성같이 등장하는게 다시금 OOP인가 싶다.  
오늘은 상속의 기본 개념, 그리고 접근지정자. 이에 더해 typescript에서 제안하는 믹스인(다중상속, 다이아몬드 상속과는 다르다.)에 대해 다뤄보자.  

# 상속

뭐, 간단하다.
상위의 변수와 함수를 물려받는다.

```ts
class Parent {
  name: string;

  constructor(name: string) {
    this.name = name;
  }

  greet() {
    console.log(`Hello, I'm ${this.name}`);
  }
}

class Child extends Parent {
  want() {
    console.log("게임을 하고싶다.");
  }
}

const parent = new Parent("엄마");
const child = new Child("학생");

parent.greet(); // Hello, I'm 엄마
parent.want(); // ❎
child.greet(); // Hello, I'm 학생
child.want(); // 게임을 하고 싶다.
```

# 접근지정자

```ts
class Person {
  public name: string; //기본 값
  readonly id: number; //읽기전용
  protected type: string; //상속된 클래스에서만 사용
  private: sn: number; //자기 자신만 사용
  #ssn: number; //ECMAScript Private, 런타임에서도 접근 불가
}
```

# 믹스인

다중상속과 비슷하지만, 다이아몬드 상속은 아니고 한 단계 위의 다중상속개념.
만약 변수나 함수가 겹치면 최종 값으로 Override됨.
타입스크립트는 믹스인을 통해 클래스가 확장되었다는 사실을 인지하지 못해서,
interface를 별도로 정의하여 클래스 간의 상속관계를 선언해줌.
무조건 쓰지는 않지만, 코드 수준의 응집도에 따라 사용될 수 있음.

```ts
function applyMixins(targetClass: any, baseClasses: any) {
  return baseClasses.forEach((baseClass) => {
    Object.getOwnPropertyNames(baseClass.prototype).forEach((name) => {
      Object.defineProperty(
        targetClass.prototype,
        name,
        Object.getOwnPropertyDescriptor(baseClass.prototype, name) ||
          Object.create(null)
      );
    });
  });
}

class Person {
  greet() {
    console.log(`Hi, I'm Person`);
  }
}

class Student {
  speak() {
    this.greet();
  }
}

interface Student extends Person {}

applyMixins(Student, [Person]);

const student = new Student();
student.speak(); // Hi, I'm Person
```
